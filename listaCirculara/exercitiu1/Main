/*gestionare a rezervarilor unei agentii de turism
struct Rezervare : cod rezervare (unsigned int), destinatie (char*),
data plecare(char*), nr turisti(unsigned int)
structura lista simpla circulara cu datele a cel putin 5 rezervari preluate dintr-un fisier text
creeare struct prin apel repetat a unei fct de inserare a unei rez noi in cadrul struct
functia care returneaza din lista simpla rezervarea cu cel mai mare nr de turisti
functia care actualizeaza data de plecare pt o rezervare pe baza de cod
functia pt destinatia cu cel mai mare nr de turisti
functia care salveaza in vector codurile rez avand un oras de plecare specificat ca parametru
dezaloc toate zonele de memorie heap*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//typedef sa evitam struct la infinit

typedef struct {
	unsigned int cod;
	char* destinatie; 
	char* oras_plecare;
	char* data_plecare;
	unsigned int nr_turisti;
} Rezervare;

typedef struct Nod {
	Rezervare *rezervare;
	struct Nod *next;
} Nod;

char* dubstr(const char* ds) {
	char* copy = malloc(strlen(ds) + 1);
	if (copy != NULL) {
		strcpy(copy, ds);
	} 
	return copy;
}

Nod* insereazaRezervare(Nod* coada, Rezervare* rez) {
	Nod* nodNou = (Nod*)malloc(sizeof(Nod));
	if (!nodNou) {
		return coada;
		}
	nodNou->rezervare = rez;
	
	//a->b->c->d nextul e sageata care se muta intr o lista circulara
	if (coada == NULL) {
		nodNou->next = nodNou;
		return nodNou;
	}
	else {
		nodNou->next = coada->next;
		coada->next = nodNou;
		return nodNou;
	}
}

Rezervare* findMaxRezervare(Nod* coada) {
	if (coada == NULL) {
		return NULL;
	}

	Nod* nodCurent = coada->next; //incepem cu capul (coada pointeaza la cap) 
	Rezervare* maxRez = nodCurent->rezervare; //initializam maxRez cu capul listei

	do { //priti obvi dar nodCurent se muta la ce pointeaza nodCurent atat timp cat nodCurent nu pointeaza iar la cap
		if (nodCurent->rezervare->nr_turisti > maxRez->nr_turisti) {
			maxRez = nodCurent->rezervare;
		}
		nodCurent = nodCurent->next;
	} while (nodCurent != coada->next);
	return maxRez;
}

//functie updateDataPleacare - cauta prin lista in fct de cod elibereaza/alocheaza
//aici avem functia aux de deep copy dubstr(dubleaza string )

void updateDataPlecare(Nod* coada, unsigned int cod, const char* data_noua){
    if(coada == NULL){
        return; //nimic ca lista e goala
    }
    Nod* nodCurent = coada->next;
    do{
        if(nodCurent->rezervare->cod == cod){
            free(nodCurent->rezervare->data_plecare);
            nodCurent->rezervare->data_plecare = dubstr(data_noua);
            break;
        }
        nodCurent = nodCurent->next;
    } while(nodCurent!=coada->next);
}

//agregate pt a calcula destinatii cu cei mai multi turisti

typedef struct{
    char* destinatie;
    unsigned int total_turisti;
} AgregatDestinatie;

//findDestinatieMaxTuristi
/*parcurgem lista si adunam nr de turisti per destinatie, dupa max nr turisti*/
char* findDestinatieMaxTuristi(Nod* coada){
    if(coada==NULL)
    return NULL;


    AgregatDestinatie agregate[100];
    int agrCount =0;

    Nod* nodCurent = coada->next;
    do{
        char* dest = nodCurent->rezervare->destinatie;
        int found =0;
        //verificam daca destinatia a mai fost vizitata
        for(int i=0;i<agrCount;i++){
            if(strcmp(agregate[i].destinatie, dest)==0){
                agregate[i].total_turisti +=nodCurent->rezervare->nr_turisti;
                found=1;
                break;
            }
        }
        if(!found){
            agregate[agrCount].destinatie = dest;
            agregate[agrCount].total_turisti = nodCurent->rezervare->nr_turisti;
            agrCount++;
        }
        nodCurent = nodCurent->next;
    } while(nodCurent !=coada->next);

    int maxIndex = 0;
    for(int i=0; i<agrCount; i++){
        if(agregate[i].total_turisti >agregate[maxIndex].total_turisti){
            maxIndex =i;
        }
    }
    return dubstr(agregate[maxIndex].destinatie);
}
